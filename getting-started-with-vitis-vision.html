

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="keywords" content="SDSoC Tutorials"/>
<meta name="description" content="The SDSoC (Software-Defined System-On-Chip) environment is an Eclipse-based Integrated Development Environment (IDE) for implementing heterogeneous embedded systems using the Zynq-7000 SoC and Zynq UltraScale+ MPSoC platforms."/>
<meta name="xlnxdocumentclass" content="Document"> 
<meta name="xlnxdocumenttypes" content="Tutorials"> 
<meta name=" xlnxproductname" content="SDSoC">
<!-- Header information provided by Emily-->
    <meta name="Language" content="en">
    <meta name="Location" content="us">
    <link rel="icon" type="image/vnd.microsoft.icon" href="https://www.xilinx.com/etc.clientlibs/site/clientlibs/xilinx/all/resources/favicon.ico">
    <link rel="shortcut icon" type="image/vnd.microsoft.icon" href="https://www.xilinx.com/etc.clientlibs/site/clientlibs/xilinx/all/resources/favicon.ico">
  
  <title>Getting Started with Vitis Vision &mdash; Vitis Vision Library  documentation</title>
  
<!-- Header information provided by Emily-->
    <meta name="apple-itunes-app" content="app-id=1063287962">
    <meta name="google-play-app" content="app-id=com.marketing.xilinxgo">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <script src="https://kit.fontawesome.com/d3dd8c60ed.js"></script>
    
    <link rel="stylesheet" href="https://www.xilinx.com/etc.clientlibs/clientlibs/granite/jquery-ui.min.css" type="text/css">
    <link rel="stylesheet" href="https://www.xilinx.com/etc.clientlibs/site/clientlibs/xilinx/header-footer.min.css" type="text/css">
    <link rel="stylesheet" href="https://www.xilinx.com/etc.clientlibs/site/clientlibs/xilinx/all.min.css" type="text/css">
    
    <script type="text/javascript" src="https://www.xilinx.com/etc.clientlibs/clientlibs/granite/jquery.min.js"></script>
    <script type="text/javascript" src="https://www.xilinx.com/etc.clientlibs/clientlibs/granite/jquery-ui.min.js"></script>
    <script type="text/javascript" src="https://www.xilinx.com/etc.clientlibs/site/clientlibs/xilinx/header-footer.min.js"></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet" type="text/css">
  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">
<div class="xilinx-bs3">
    <noindex>
        <header data-component="header">
            <nav class="navbar navbar-default">
                <div class="container main-nav">
                    <div class="row">
                        <div class="col-xs-5 col-sm-2 logo-column">
                            <div class="logo">
                                <a href="https://www.xilinx.com/">
                                    <img src="https://www.xilinx.com/etc.clientlibs/site/clientlibs/xilinx/all/resources/imgs/header/xilinx-header-logo.svg" title="Xilinx Inc" />
                                </a>
                            </div>
                        </div>
                        <div class="col-xs-12 col-sm-8 navbar-column">
                            <div class="navbar navbar-collapse collapse" id="xilinx-main-menu">
                                <ul class="nav navbar-nav nav-justified">
                                    <li class="accordion-toggle-icons" data-component="toggle-dropdown">
                                        <a href="https://developer.xilinx.com/">
                                            Developers
                                        </a>
                                    </li>
                                    <li class="accordion-toggle-icons" data-component="toggle-dropdown">
                                        <a href="https://www.xilinx.com/support.html">
                                            Support
                                        </a>
                                    </li>
                                    <li class="accordion-toggle-icons" data-component="toggle-dropdown">
                                        <a href="https://forums.xilinx.com/">
                                            Forums
                                        </a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                        <div class="mini-nav col-sm-2">
                            <button type="button" data-function="xilinx-mobile-menu" id="nav-toggle" class="navbar-toggle collapsed visible-xs-block" aria-expanded="false">
                                <span></span>
                                <span></span>
                                <span></span>
                                <span></span>
                            </button>
                        </div>
                    </div>
                </div>
            </nav>
        </header>
    </noindex>
</div>
   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Vitis Vision Library
          

          
          </a>

          
            
            
              <div class="version">
                v1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Vitis Vision Library User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#getting-started-with-vitis-vision">Getting Started with Vitis Vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#getting-started-with-hls">Getting Started with HLS</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#design-examples-using-vitis-vision-library">Design Examples Using Vitis Vision Library</a></li>
</ul>
<p class="caption"><span class="caption-text">Vitis Vision Library API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#xf-mat-image-container-class">xf::Mat Image Container Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#xfopencv-library-functions">xfOpenCV Library Functions</a></li>
</ul>

            
			<p class="caption"><span class="caption-text">This Page</span></p>
				<ul class="current">
				  <li class="toctree-l1"><a href="_sources/getting-started-with-vitis-vision.rst.txt"
						rel="nofollow">Show Source</a></li>
					<li class="toctree-l1"><a href="https://github.com/gitenterprise.xilinx.com/FaaSApps/Vitis_Libraries/blob/master/vision/docs//getting-started-with-vitis-vision.rst"
						   rel="nofollow">View on GitHub</a></li>						
				</ul>
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Vitis Vision Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Getting Started with Vitis Vision</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/getting-started-with-vitis-vision.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-started-with-vitis-vision">
<h1>Getting Started with Vitis Vision<a class="headerlink" href="#getting-started-with-vitis-vision" title="Permalink to this headline">¶</a></h1>
<p>This chapter provides details on using xfOpenCV in the Vitis™
environment. The following sections would provide a description of the
methodology to create a kernel, corresponding host code and a suitable
makefile to compile an xfOpenCV kernel for any of the supported
platforms in Vitis. The subsequent section also explains the
methodology to verify the kernel in various emulation modes and on the
hardware.</p>
<div class="section" id="prerequisites">
<span id="id1"></span><h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Valid installation of Vitis™ 2019.2 or later version and the
corresponding licenses.</li>
<li>Install the xfOpenCV libraries, if you intend to use libraries
compiled differently than what is provided in Vitis.</li>
<li>Install the card for which the platform is supported in Vitis 2019.2 or
later versions.</li>
<li>Xilinx® Runtime (XRT) must be installed. XRT provides software
interface to Xilinx FPGAs.</li>
<li>libOpenCL.so must be installed if not present along with the
platform.</li>
</ol>
</div>
<div class="section" id="vitis-design-methodology">
<h2>Vitis Design Methodology<a class="headerlink" href="#vitis-design-methodology" title="Permalink to this headline">¶</a></h2>
<p>There are three critical components in making a kernel work on a
platform using Vitis™:</p>
<ol class="arabic simple">
<li>Host code with OpenCL constructs</li>
<li>Wrappers around HLS Kernel(s)</li>
<li>Makefile to compile the kernel for emulation or running on hardware.</li>
</ol>
<div class="section" id="host-code-with-opencl">
<h3>Host Code with OpenCL<a class="headerlink" href="#host-code-with-opencl" title="Permalink to this headline">¶</a></h3>
<p>Host code is compiled for the host machine that runs on the host and
provides the data and control signals to the attached hardware with the
FPGA. The host code is written using OpenCL constructs and provides
capabilities for setting up, and running a kernel on the FPGA. The
following functions are executed using the host code:</p>
<ol class="arabic simple">
<li>Loading the kernel binary on the FPGA – xcl::import_binary_file()
loads the bitstream and programs the FPGA to enable required
processing of data.</li>
<li>Setting up memory buffers for data transfer – Data needs to be sent
and read from the DDR memory on the hardware. cl::Buffers are created
to allocate required memory for transferring data to and from the
hardware.</li>
<li>Transfer data to and from the hardware –enqueueWriteBuffer() and
enqueueReadBuffer() are used to transfer the data to and from the
hardware at the required time.</li>
<li>Execute kernel on the FPGA – There are functions to execute kernels
on the FPGA. There can be single kernel execution or multiple kernel
execution that could be asynchronous or synchronous with each other.
Commonly used command is enqueueTask().</li>
<li>Profiling the performance of kernel execution – The host code in
OpenCL also enables measurement of the execution time of a kernel on
the FPGA. The function used in our examples for profiling is
getProfilingInfo().</li>
</ol>
</div>
<div class="section" id="wrappers-around-hls-kernel-s">
<h3>Wrappers around HLS Kernel(s)<a class="headerlink" href="#wrappers-around-hls-kernel-s" title="Permalink to this headline">¶</a></h3>
<p>All xfOpenCV kernels are provided with C++ function templates (located
at &lt;Github repo&gt;/include) with image containers as objects of xf::Mat
class. In addition, these kernels will work either in stream based
(where complete image is read continuously) or memory mapped (where
image data access is in blocks).</p>
<p>Vitis flow (OpenCL) requires kernel interfaces to be memory pointers
with width in power(s) of 2. So glue logic is required for converting
memory pointers to xf::Mat class data type and vice-versa when
interacting with xfOpenCV kernel(s). Wrapper(s) are build over the
kernel(s) with this glue logic. Below examples will provide a
methodology to handle different kernel (xfOpenCV kernels located at
&lt;Github repo&gt;/include) types (stream and memory mapped).</p>
<div class="section" id="stream-based-kernels">
<h4>Stream Based Kernels<a class="headerlink" href="#stream-based-kernels" title="Permalink to this headline">¶</a></h4>
<p>To facilitate the conversion of pointer to xf::Mat and vice versa, two
adapter functions are included as part of xfOpenCV xf::cv::Array2xfMat() and
xf::cv::xfMat2Array(). It is necessary for the xf::Mat objects to be invoked
as streams using HLS pragma with a minimum depth of 2. This results in a
top-level (or wrapper) function for the kernel as shown below:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>extern “C”
{
void func_top (ap_uint *gmem_in, ap_uint *gmem_out, ...) {
xf::cv::Mat&lt;…&gt; in_mat(…), out_mat(…);
#pragma HLS stream variable=in_mat.data depth=2
#pragma HLS stream variable=out_mat.data depth=2
#pragma HLS dataflow
xf::cv::Array2xfMat&lt;…&gt; (gmem_in, in_mat);
xf::xfopencv-func&lt;…&gt; (in_mat, out_mat…);
xf::cv::xfMat2Array&lt;…&gt; (gmem_out, out_mat);
}
}
</pre></div>
</div>
<p>The above illustration assumes that the data in xf::cv::Mat is being
streamed in and streamed out. You can also create a pipeline with
multiple functions in pipeline instead of just one xfopencv function.</p>
<p>For the stream based kernels with different inputs of different sizes,
multiple instances of the adapter functions are necessary. For this,</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>extern “C” {
void func_top (ap_uint *gmem_in1, ap_uint *gmem_in2, ap_uint *gmem_in3, ap_uint *gmem_out, ...) {
xf::cv::Mat&lt;...,HEIGHT,WIDTH,…&gt; in_mat1(…), out_mat(…);
xf::cv::Mat&lt;...,HEIGHT/4,WIDTH,…&gt;  in_mat2(…), in_mat3(…);
#pragma HLS stream variable=in_mat1.data depth=2
#pragma HLS stream variable=in_mat2.data depth=2
#pragma HLS stream variable=in_mat3.data depth=2
#pragma HLS stream variable=out_mat.data depth=2
#pragma HLS dataflow
xf::accel_utils obj_a, obj_b;
obj_a.Array2xfMat&lt;…,HEIGHT,WIDTH,…&gt; (gmem_in1, in_mat1);
obj_b.Array2xfMat&lt;…,HEIGHT/4,WIDTH,…&gt; (gmem_in2, in_mat2);
obj_b.Array2xfMat&lt;…,HEIGHT/4,WIDTH,…&gt; (gmem_in3, in_mat3);
xf::xfopencv-func(in_mat1, in_mat2, int_mat3, out_mat…);
xf::cv::xfMat2Array&lt;…&gt; (gmem_out, out_mat);
}
}
</pre></div>
</div>
<p>For the stream based implementations, the data must be fetched from the
input AXI and must be pushed to xfMat as required by the xfcv kernels
for that particular configuration. Likewise, the same operations must be
performed for the output of the xfcv kernel. To perform this, two
utility functions are provided, xf::cv::Array2xfMat() and xf::cv::xfMat2Array().</p>
<div class="section" id="array2xfmat">
<h5>Array2xfMat<a class="headerlink" href="#array2xfmat" title="Permalink to this headline">¶</a></h5>
<p>This function converts the input array to xf::cv::Mat. The xfOpenCV kernel
would require the input to be of type, xf::cv::Mat. This function would read
from the array pointer and write into xf::cv::Mat based on the particular
configuration (bit-depth, channels, pixel-parallelism) the xf::cv::Mat was
created.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="nb">int</span> <span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="nb">int</span> <span class="n">MAT_T</span><span class="p">,</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">NPC</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">Array2xfMat</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span> <span class="n">PTR_WIDTH</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">srcPtr</span><span class="p">,</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">MAT_T</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span><span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="o">&gt;&amp;</span> <span class="n">dstMat</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils" id="id2">
<caption><span class="caption-text">Table. Array2xfMat Parmater Description</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PTR_WIDTH</td>
<td>Data width of the input pointer.
The value must be power 2,
starting from 8 to 512.</td>
</tr>
<tr class="row-odd"><td>MAT_T</td>
<td>Input Mat type. Example XF_8UC1,
XF_16UC1, XF_8UC3 and XF_8UC4</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of image</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of image</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels computed in
parallel. Example XF_NPPC1,
XF_NPPC8</td>
</tr>
<tr class="row-odd"><td>srcPtr</td>
<td>Input pointer. Type of the
pointer based on the PTR_WIDTH.</td>
</tr>
<tr class="row-even"><td>dstMat</td>
<td>Output image of type xf::cv::Mat</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="xfmat2array">
<h5>xfMat2Array<a class="headerlink" href="#xfmat2array" title="Permalink to this headline">¶</a></h5>
<p>This function converts the input xf::cv::Mat to output array. The output of
the xf::kernel function will be xf::cv::Mat, and it will require to convert
that to output pointer.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="nb">int</span> <span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="nb">int</span> <span class="n">MAT_T</span><span class="p">,</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">NPC</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">xfMat2Array</span><span class="p">(</span><span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">MAT_T</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span><span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="o">&gt;&amp;</span> <span class="n">srcMat</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span> <span class="n">PTR_WIDTH</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">dstPtr</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils" id="id3">
<caption><span class="caption-text">Table . xfMat2Array Parameter Description</span><a class="headerlink" href="#id3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PTR_WIDTH</td>
<td>Data width of the output pointer.
The value must be power 2, from 8
to 512.</td>
</tr>
<tr class="row-odd"><td>MAT_T</td>
<td>Input Mat type. Example XF_8UC1,
XF_16UC1, XF_8UC3 and XF_8UC4</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of image</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of image</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels computed in
parallel. Example XF_NPPC1,
XF_NPPC8</td>
</tr>
<tr class="row-odd"><td>dstPtr</td>
<td>Output pointer. Type of the
pointer based on the PTR_WIDTH.</td>
</tr>
<tr class="row-even"><td>srcMat</td>
<td>Input image of type xf::cv::Mat</td>
</tr>
</tbody>
</table>
<div class="section" id="interface-pointer-widths">
<h6>Interface pointer widths<a class="headerlink" href="#interface-pointer-widths" title="Permalink to this headline">¶</a></h6>
<p>Minimum pointer widths for different configurations is shown in the
following table:</p>
<p>types</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">MAT type</th>
<th class="head">Parallelism</th>
<th class="head">Min PTR_WIDTH</th>
<th class="head">Max PTR_WIDTH</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_8UC1</td>
<td>XF_NPPC1</td>
<td>8</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_16UC1</td>
<td>XF_NPPC1</td>
<td>16</td>
<td>512</td>
</tr>
<tr class="row-even"><td>XF_ 8UC1</td>
<td>XF_NPPC8</td>
<td>64</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_ 16UC1</td>
<td>XF_NPPC8</td>
<td>128</td>
<td>512</td>
</tr>
<tr class="row-even"><td>XF_ 8UC3</td>
<td>XF_NPPC1</td>
<td>32</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_ 8UC3</td>
<td>XF_NPPC8</td>
<td>256</td>
<td>512</td>
</tr>
<tr class="row-even"><td>XF_8UC4</td>
<td>XF_NPPC8</td>
<td>256</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_8UC3</td>
<td>XF_NPPC16</td>
<td>512</td>
<td>512</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="memory-mapped-kernels">
<h4>Memory Mapped Kernels<a class="headerlink" href="#memory-mapped-kernels" title="Permalink to this headline">¶</a></h4>
<p>In the memory map based kernels such as crop, Mean-shift tracking and
bounding box, the input read will be for particular block of memory
based on the requirement for the algorithm. The streaming interfaces
will require the image to be read in raster scan manner, which is not
the case for the memory mapped kernels. The methodology to handle this
case is as follows:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>extern “C”
{
void func_top (ap_uint *gmem_in, ap_uint *gmem_out, ...) {
xf::cv::Mat&lt;…&gt; in_mat(…,gmem_in), out_mat(…,gmem_out);
xf::kernel&lt;…&gt; (in_mat, out_mat…);
}
}
</pre></div>
</div>
<p>The gmem pointers must be mapped to the xf::cv::Mat objects during the
object creation, and then the memory mapped kernels are called with
these mats at the interface. It is necessary that the pointer size must
be same as the size required for the xf::xfopencv-func, unlike the
streaming method where any higher size of the pointers (till 512-bits)
are allowed.</p>
</div>
</div>
<div class="section" id="makefile">
<h3>Makefile<a class="headerlink" href="#makefile" title="Permalink to this headline">¶</a></h3>
<p>In the current use model, only a makefile based flow is provided to
build applications with xfOpenCV on Vitis. Examples for makefile are
provided in the samples section of GitHub.</p>
</div>
<div class="section" id="design-example-using-library-on-vitis">
<h3>Design example Using Library on Vitis<a class="headerlink" href="#design-example-using-library-on-vitis" title="Permalink to this headline">¶</a></h3>
<p>Following is a multi-kernel example, where different kernel runs
sequentially in a pipeline to form an application. This example performs
Canny edge detection, where two kernels are involved, Canny and edge
tracing. Canny function will take gray-scale image as input and provided
the edge information in 3 states (weak edge (1), strong edge (3), and
background (0)), which is being fed into edge tracing, which filters out
the weak edges. The prior works in a streaming based implementation and
the later in a memory mapped manner.</p>
<div class="section" id="host-code">
<h4>Host code<a class="headerlink" href="#host-code" title="Permalink to this headline">¶</a></h4>
<p>The following is the Host code for the canny edge detection example. The
host code sets up the OpenCL platform with the FPGA of processing
required data. In the case of xfOpenCV example, the data is an image.
Reading and writing of images are enabled using called to functions from
xfOpenCV.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">setting</span> <span class="n">up</span> <span class="n">device</span> <span class="ow">and</span> <span class="n">platform</span>
    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">Device</span><span class="o">&gt;</span> <span class="n">devices</span> <span class="o">=</span> <span class="n">xcl</span><span class="p">::</span><span class="n">get_xil_devices</span><span class="p">();</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Device</span> <span class="n">device</span> <span class="o">=</span> <span class="n">devices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Context</span> <span class="n">context</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">CommandQueue</span> <span class="n">q</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span><span class="n">CL_QUEUE_PROFILING_ENABLE</span><span class="p">);</span>
    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">device_name</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">CL_DEVICE_NAME</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Kernel</span> <span class="mi">1</span><span class="p">:</span> <span class="n">Canny</span>
    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">binaryFile</span><span class="o">=</span><span class="n">xcl</span><span class="p">::</span><span class="n">find_binary_file</span><span class="p">(</span><span class="n">device_name</span><span class="p">,</span><span class="s2">&quot;krnl_canny&quot;</span><span class="p">);</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Program</span><span class="p">::</span><span class="n">Binaries</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">xcl</span><span class="p">::</span><span class="n">import_binary_file</span><span class="p">(</span><span class="n">binaryFile</span><span class="p">);</span>
    <span class="n">devices</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Program</span> <span class="n">program</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">devices</span><span class="p">,</span> <span class="n">bins</span><span class="p">);</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Kernel</span> <span class="n">krnl</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="s2">&quot;canny_accel&quot;</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">creating</span> <span class="n">necessary</span> <span class="n">cl</span> <span class="n">buffers</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">and</span> <span class="n">output</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Buffer</span> <span class="n">imageToDevice</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CL_MEM_READ_ONLY</span><span class="p">,(</span><span class="n">height</span><span class="o">*</span><span class="n">width</span><span class="p">));</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Buffer</span> <span class="n">imageFromDevice</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,(</span><span class="n">height</span><span class="o">*</span><span class="n">width</span><span class="o">/</span><span class="mi">4</span><span class="p">));</span>


    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">kernel</span> <span class="n">arguments</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">imageToDevice</span><span class="p">);</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">imageFromDevice</span><span class="p">);</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">low_threshold</span><span class="p">);</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">high_threshold</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">write</span> <span class="n">the</span> <span class="nb">input</span> <span class="n">image</span> <span class="n">data</span> <span class="kn">from</span> <span class="nn">host</span> <span class="n">to</span> <span class="n">device</span> <span class="n">memory</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">imageToDevice</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,(</span><span class="n">height</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="p">)),</span><span class="n">img_gray</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
    <span class="o">//</span> <span class="n">Profiling</span> <span class="n">Objects</span>
    <span class="n">cl_ulong</span> <span class="n">start</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cl_ulong</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">double</span> <span class="n">diff_prof</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Event</span> <span class="n">event_sp</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Launch</span> <span class="n">the</span> <span class="n">kernel</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">krnl</span><span class="p">,</span><span class="n">NULL</span><span class="p">,</span><span class="o">&amp;</span><span class="n">event_sp</span><span class="p">);</span>
    <span class="n">clWaitForEvents</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">cl_event</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">event_sp</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">profiling</span>
    <span class="n">event_sp</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_START</span><span class="p">,</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
    <span class="n">event_sp</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_END</span><span class="p">,</span><span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
    <span class="n">diff_prof</span> <span class="o">=</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">diff_prof</span><span class="o">/</span><span class="mi">1000000</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s2">&quot;ms&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Kernel</span> <span class="mi">2</span><span class="p">:</span> <span class="n">edge</span> <span class="n">tracing</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Kernel</span> <span class="n">krnl2</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="s2">&quot;edgetracing_accel&quot;</span><span class="p">);</span>

    <span class="n">cl</span><span class="p">::</span><span class="n">Buffer</span> <span class="n">imageFromDeviceedge</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,(</span><span class="n">height</span><span class="o">*</span><span class="n">width</span><span class="p">));</span>

    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">kernel</span> <span class="n">arguments</span>
    <span class="n">krnl2</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">imageFromDevice</span><span class="p">);</span>
    <span class="n">krnl2</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">imageFromDeviceedge</span><span class="p">);</span>
    <span class="n">krnl2</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
    <span class="n">krnl2</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">Profiling</span> <span class="n">Objects</span>
    <span class="n">cl_ulong</span> <span class="n">startedge</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cl_ulong</span> <span class="n">endedge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">double</span> <span class="n">diff_prof_edge</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Event</span> <span class="n">event_sp_edge</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Launch</span> <span class="n">the</span> <span class="n">kernel</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">krnl2</span><span class="p">,</span><span class="n">NULL</span><span class="p">,</span><span class="o">&amp;</span><span class="n">event_sp_edge</span><span class="p">);</span>
    <span class="n">clWaitForEvents</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">cl_event</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">event_sp_edge</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">profiling</span>
    <span class="n">event_sp_edge</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_START</span><span class="p">,</span><span class="o">&amp;</span><span class="n">startedge</span><span class="p">);</span>
    <span class="n">event_sp_edge</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_END</span><span class="p">,</span><span class="o">&amp;</span><span class="n">endedge</span><span class="p">);</span>
    <span class="n">diff_prof_edge</span> <span class="o">=</span> <span class="n">endedge</span><span class="o">-</span><span class="n">startedge</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">diff_prof_edge</span><span class="o">/</span><span class="mi">1000000</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s2">&quot;ms&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>


    <span class="o">//</span><span class="n">Copying</span> <span class="n">Device</span> <span class="n">result</span> <span class="n">data</span> <span class="n">to</span> <span class="n">Host</span> <span class="n">memory</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">imageFromDeviceedge</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,(</span><span class="n">height</span><span class="o">*</span><span class="n">width</span><span class="p">),</span><span class="n">out_img_edge</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">q</span><span class="o">.</span><span class="n">finish</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="top-level-kernel">
<h4>Top level kernel<a class="headerlink" href="#top-level-kernel" title="Permalink to this headline">¶</a></h4>
<p>Below is the top-level/wrapper function with all necessary glue logic.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">streaming</span> <span class="n">based</span> <span class="n">kernel</span>
<span class="c1">#include &quot;xf_canny_config.h&quot;</span>

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="p">{</span>
<span class="n">void</span> <span class="n">canny_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols</span><span class="p">,</span><span class="nb">int</span> <span class="n">low_threshold</span><span class="p">,</span><span class="nb">int</span> <span class="n">high_threshold</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=img_inp  bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=img_out  bundle=control</span>

<span class="c1">#pragma HLS INTERFACE s_axilite port=rows     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=low_threshold     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=high_threshold     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=return   bundle=control</span>

    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">INTYPE</span><span class="o">&gt;</span> <span class="n">in_mat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">);</span>
<span class="c1">#pragma HLS stream variable=in_mat.data depth=2</span>

    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_2UC1</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC32</span><span class="o">&gt;</span> <span class="n">dst_mat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">);</span>
<span class="c1">#pragma HLS stream variable=dst_mat.data depth=2</span>


    <span class="c1">#pragma HLS DATAFLOW</span>

    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span><span class="n">XF_8UC1</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">INTYPE</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_inp</span><span class="p">,</span><span class="n">in_mat</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">Canny</span><span class="o">&lt;</span><span class="n">FILTER_WIDTH</span><span class="p">,</span><span class="n">NORM_TYPE</span><span class="p">,</span><span class="n">XF_8UC1</span><span class="p">,</span><span class="n">XF_2UC1</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span><span class="n">INTYPE</span><span class="p">,</span><span class="n">XF_NPPC32</span><span class="p">,</span><span class="n">XF_USE_URAM</span><span class="o">&gt;</span><span class="p">(</span><span class="n">in_mat</span><span class="p">,</span><span class="n">dst_mat</span><span class="p">,</span><span class="n">low_threshold</span><span class="p">,</span><span class="n">high_threshold</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span><span class="n">XF_2UC1</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">XF_NPPC32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dst_mat</span><span class="p">,</span><span class="n">img_out</span><span class="p">);</span>


<span class="p">}</span>
<span class="p">}</span>
<span class="o">//</span> <span class="n">memory</span> <span class="n">mapped</span> <span class="n">kernel</span>
<span class="c1">#include &quot;xf_canny_config.h&quot;</span>
<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="p">{</span>
<span class="n">void</span> <span class="n">edgetracing_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem4</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=img_inp  bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=img_out  bundle=control</span>

<span class="c1">#pragma HLS INTERFACE s_axilite port=rows     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=return   bundle=control</span>


    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_2UC1</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC32</span><span class="o">&gt;</span> <span class="n">_dst1</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">,</span><span class="n">img_inp</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC8</span><span class="o">&gt;</span> <span class="n">_dst2</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">,</span><span class="n">img_out</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">EdgeTracing</span><span class="o">&lt;</span><span class="n">XF_2UC1</span><span class="p">,</span><span class="n">XF_8UC1</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC32</span><span class="p">,</span><span class="n">XF_NPPC8</span><span class="p">,</span><span class="n">XF_USE_URAM</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_dst1</span><span class="p">,</span><span class="n">_dst2</span><span class="p">);</span>

<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="evaluating-the-functionality">
<h2>Evaluating the Functionality<a class="headerlink" href="#evaluating-the-functionality" title="Permalink to this headline">¶</a></h2>
<p>You can build the kernels and test the functionality through software
emulation, hardware emulation, and running directly on a supported
hardware with the FPGA. For PCIe based platforms, use the following
commands to setup the environment:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd &lt;path to the folder where makefile is present&gt;
$ source &lt;path to the Vitis installation folder&gt;/Vitis/&lt;version number&gt;/settings64.sh
$ source &lt;path to Xilinx_xrt&gt;/packages/setenv.sh
$ export DEVICE=&lt;path to the platform folder&gt;
</pre></div>
</div>
<div class="section" id="software-emulation">
<h3>Software Emulation<a class="headerlink" href="#software-emulation" title="Permalink to this headline">¶</a></h3>
<p>Software emulation is equivalent to running a C-simulation of the
kernel. The time for compilation is minimal, and is therefore
recommended to be the first step in testing the kernel. Following are
the steps to build and run for the software emulation:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>     *For PCIe devices:*
$ make host xclbin TARGET=sw_emu
$ make run TARGET=sw_emu
     *For embedded devices:*
$ export SYSROOT=&lt; path-to-platform-sysroot &gt;
$ make host xclbin TARGET=hw BOARD=Zynq
$ make run TARGET=sw_emu
</pre></div>
</div>
</div>
<div class="section" id="hardware-emulation">
<h3>Hardware Emulation<a class="headerlink" href="#hardware-emulation" title="Permalink to this headline">¶</a></h3>
<p>Hardware emulation runs the test on the generated RTL after synthesis of
the C/C++ code. The simulation, since being done on RTL requires longer
to complete when compared to software emulation. Following are the steps
to build and run for the hardware emulation:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>     *For PCIe devices:*
$ make host xclbin TARGET=hw_emu
$ make run TARGET=hw_emu
     *For embedded devices:*
$ export SYSROOT=&lt; path-to-platform-sysroot &gt;
$ make host xclbin TARGET=hw_emu BOARD=Zynq
$ make run TARGET=hw_emu
</pre></div>
</div>
</div>
<div class="section" id="testing-on-the-hardware">
<h3>Testing on the Hardware<a class="headerlink" href="#testing-on-the-hardware" title="Permalink to this headline">¶</a></h3>
<p>To test on the hardware, the kernel must be compiled into a bitstream
(building for hardware). This would consume some time since the C/C++ code must be converted to
RTL, run through synthesis and implementation process before a bitstream
is created. As a prerequisite the drivers has to be installed for
corresponding DSA, for which the example was built for. Following are
the steps to build the kernel and run on a hardware:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>     *For PCIe devices:*
$ make host xclbin TARGET=hw
$ make run TARGET=hw
     *For embedded devices:*
$ export SYSROOT=&lt; path-to-platform-sysroot &gt;
$ make host xclbin TARGET=hw BOARD=Zynq
copy the generated sd_card folder contents to an SDCARD and run on the following commands on the board.
$ export LD_LIBRARY_PATH=&lt; path-to-arm-compiled-opencv-libs &gt;
$ export XILINX_XRT=/usr
$ ./&lt; executable &gt; &lt; args &gt;
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo" class="copyright">
    <p>
        
        &copy; Copyright 2019, Xilinx

    </p>
  </div>
<!--
    
    
      Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 
-->
</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>