

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Getting Started with SDAccel &mdash; xfOpenCV v1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> xfOpenCV
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">xfOpenCV Library User Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html">xfOpenCV Library API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">xfOpenCV</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Getting Started with SDAccel</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/getting-started-with-sdaccel.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-started-with-sdaccel">
<span id="ariaid-title1"></span><h1>Getting Started with SDAccel<a class="headerlink" href="#getting-started-with-sdaccel" title="Permalink to this headline">¶</a></h1>
<p>This chapter provides details on using xfOpenCV in the SDAccel™
environment. The following sections would provide a description of the
methodology to create a kernel, corresponding host code and a suitable
makefile to compile an xfOpenCV kernel for any of the supported
platforms in SDAccel. The subsequent section also explains the
methodology to verify the kernel in various emulation modes and on the
hardware.</p>
<div class="section" id="prerequisites">
<span id="ariaid-title2"></span><h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Valid installation of SDx™ 2019.1 or later version and the
corresponding licenses.</li>
<li>Install the xfOpenCV libraries, if you intend to use libraries
compiled differently than what is provided in SDx.</li>
<li>Install the card for which the platform is supported in SDx 2019.1 or
later versions.</li>
<li>Xilinx® Runtime (XRT) must be installed. XRT provides software
interface to Xilinx FPGAs.</li>
<li>libOpenCL.so must be installed if not present along with the
platform.</li>
</ol>
</div>
<div class="section" id="sdaccel-design-methodology">
<span id="ariaid-title3"></span><h2>SDAccel Design Methodology<a class="headerlink" href="#sdaccel-design-methodology" title="Permalink to this headline">¶</a></h2>
<p>There are three critical components in making a kernel work on a
platform using SDAccel™:</p>
<ol class="arabic simple">
<li>Host code with OpenCL constructs</li>
<li>Wrappers around HLS Kernel(s)</li>
<li>Makefile to compile the kernel for emulation or running on hardware.</li>
</ol>
<div class="section" id="host-code-with-opencl">
<span id="ariaid-title4"></span><h3>Host Code with OpenCL<a class="headerlink" href="#host-code-with-opencl" title="Permalink to this headline">¶</a></h3>
<p>Host code is compiled for the host machine that runs on the host and
provides the data and control signals to the attached hardware with the
FPGA. The host code is written using OpenCL constructs and provides
capabilities for setting up, and running a kernel on the FPGA. The
following functions are executed using the host code:</p>
<ol class="arabic simple">
<li>Loading the kernel binary on the FPGA – xcl::import_binary_file()
loads the bitstream and programs the FPGA to enable required
processing of data.</li>
<li>Setting up memory buffers for data transfer – Data needs to be sent
and read from the DDR memory on the hardware. cl::Buffers are created
to allocate required memory for transferring data to and from the
hardware.</li>
<li>Transfer data to and from the hardware –enqueueWriteBuffer() and
enqueueReadBuffer() are used to transfer the data to and from the
hardware at the required time.</li>
<li>Execute kernel on the FPGA – There are functions to execute kernels
on the FPGA. There can be single kernel execution or multiple kernel
execution that could be asynchronous or synchronous with each other.
Commonly used command is enqueueTask().</li>
<li>Profiling the performance of kernel execution – The host code in
OpenCL also enables measurement of the execution time of a kernel on
the FPGA. The function used in our examples for profiling is
getProfilingInfo().</li>
</ol>
</div>
<div class="section" id="wrappers-around-hls-kernel-s">
<span id="ariaid-title5"></span><h3>Wrappers around HLS Kernel(s)<a class="headerlink" href="#wrappers-around-hls-kernel-s" title="Permalink to this headline">¶</a></h3>
<p>All xfOpenCV kernels are provided with C++ function templates (located
at &lt;Github repo&gt;/include) with image containers as objects of xf::Mat
class. In addition, these kernels will work either in stream based
(where complete image is read continuously) or memory mapped (where
image data access is in blocks).</p>
<p>SDAccel flow (OpenCL) requires kernel interfaces to be memory pointers
with width in power(s) of 2. So glue logic is required for converting
memory pointers to xf::Mat class data type and vice-versa when
interacting with xfOpenCV kernel(s). Wrapper(s) are build over the
kernel(s) with this glue logic. Below examples will provide a
methodology to handle different kernel (xfOpenCV kernels located at
&lt;Github repo&gt;/include) types (stream and memory mapped).</p>
<div class="section" id="stream-based-kernels">
<span id="ariaid-title6"></span><h4>Stream Based Kernels<a class="headerlink" href="#stream-based-kernels" title="Permalink to this headline">¶</a></h4>
<p>To facilitate the conversion of pointer to xf::Mat and vice versa, two
adapter functions are included as part of xfOpenCV xf::Array2xfMat() and
xf::xfMat2Array(). It is necessary for the xf::Mat objects to be invoked
as streams using HLS pragma with a minimum depth of 2. This results in a
top-level (or wrapper) function for the kernel as shown below:</p>
<p>The above illustration assumes that the data in xf::Mat is being
streamed in and streamed out. You can also create a pipeline with
multiple functions in pipeline instead of just one xfopencv function.</p>
<p>For the stream based kernels with different inputs of different sizes,
multiple instances of the adapter functions are necessary. For this,</p>
<p>For the stream based implementations, the data must be fetched from the
input AXI and must be pushed to xfMat as required by the xfcv kernels
for that particular configuration. Likewise, the same operations must be
performed for the output of the xfcv kernel. To perform this, two
utility functions are provided, xf::Array2xfMat() and xf::xfMat2Array().</p>
<div class="section" id="array2xfmat">
<span id="ariaid-title7"></span><h5>Array2xfMat<a class="headerlink" href="#array2xfmat" title="Permalink to this headline">¶</a></h5>
<p>This function converts the input array to xf::Mat. The xfOpenCV kernel
would require the input to be of type, xf::Mat. This function would read
from the array pointer and write into xf::Mat based on the particular
configuration (bit-depth, channels, pixel-parallelism) the xf::Mat was
created.</p>
<table border="1" class="docutils" id="id1">
<caption><span class="caption-text">Table 1. Array2xfMat Parmater Description</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PTR_WIDTH</td>
<td>Data width of the input pointer.
The value must be power 2,
starting from 8 to 512.</td>
</tr>
<tr class="row-odd"><td>MAT_T</td>
<td>Input Mat type. Example XF_8UC1,
XF_16UC1, XF_8UC3 and XF_8UC4</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of image</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of image</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels computed in
parallel. Example XF_NPPC1,
XF_NPPC8</td>
</tr>
<tr class="row-odd"><td>srcPtr</td>
<td>Input pointer. Type of the
pointer based on the PTR_WIDTH.</td>
</tr>
<tr class="row-even"><td>dstMat</td>
<td>Output image of type xf::Mat</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="xfmat2array">
<span id="ariaid-title8"></span><h5>xfMat2Array<a class="headerlink" href="#xfmat2array" title="Permalink to this headline">¶</a></h5>
<p>This function converts the input xf::Mat to output array. The output of
the xf::kernel function will be xf::Mat, and it will require to convert
that to output pointer.</p>
<table border="1" class="docutils" id="id2">
<caption><span class="caption-text">Table 2. xfMat2Array Parameter Description</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PTR_WIDTH</td>
<td>Data width of the output pointer.
The value must be power 2, from 8
to 512.</td>
</tr>
<tr class="row-odd"><td>MAT_T</td>
<td>Input Mat type. Example XF_8UC1,
XF_16UC1, XF_8UC3 and XF_8UC4</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of image</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of image</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels computed in
parallel. Example XF_NPPC1,
XF_NPPC8</td>
</tr>
<tr class="row-odd"><td>dstPtr</td>
<td>Output pointer. Type of the
pointer based on the PTR_WIDTH.</td>
</tr>
<tr class="row-even"><td>srcMat</td>
<td>Input image of type xf::Mat</td>
</tr>
</tbody>
</table>
<p><strong>Interface pointer widths</strong></p>
<p>Minimum pointer widths for different configurations is shown in the
following table:</p>
<p>types</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">MAT type</th>
<th class="head">Parallelism</th>
<th class="head">Min PTR_WIDTH</th>
<th class="head">Max PTR_WIDTH</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_8UC1</td>
<td>XF_NPPC1</td>
<td>8</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_16UC1</td>
<td>XF_NPPC1</td>
<td>16</td>
<td>512</td>
</tr>
<tr class="row-even"><td>XF_ 8UC1</td>
<td>XF_NPPC8</td>
<td>64</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_ 16UC1</td>
<td>XF_NPPC8</td>
<td>128</td>
<td>512</td>
</tr>
<tr class="row-even"><td>XF_ 8UC3</td>
<td>XF_NPPC1</td>
<td>32</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_ 8UC3</td>
<td>XF_NPPC8</td>
<td>256</td>
<td>512</td>
</tr>
<tr class="row-even"><td>XF_8UC4</td>
<td>XF_NPPC8</td>
<td>256</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_8UC3</td>
<td>XF_NPPC16</td>
<td>512</td>
<td>512</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="memory-mapped-kernels">
<span id="ariaid-title9"></span><h4>Memory Mapped Kernels<a class="headerlink" href="#memory-mapped-kernels" title="Permalink to this headline">¶</a></h4>
<p>In the memory map based kernels such as crop, Mean-shift tracking and
bounding box, the input read will be for particular block of memory
based on the requirement for the algorithm. The streaming interfaces
will require the image to be read in raster scan manner, which is not
the case for the memory mapped kernels. The methodology to handle this
case is as follows:</p>
<p>The gmem pointers must be mapped to the xf::Mat objects during the
object creation, and then the memory mapped kernels are called with
these mats at the interface. It is necessary that the pointer size must
be same as the size required for the xf::xfopencv-func, unlike the
streaming method where any higher size of the pointers (till 512-bits)
are allowed.</p>
</div>
</div>
<div class="section" id="makefile">
<span id="ariaid-title10"></span><h3>Makefile<a class="headerlink" href="#makefile" title="Permalink to this headline">¶</a></h3>
<p>In the current use model, only a makefile based flow is provided to
build applications with xfOpenCV on SDAccel. Examples for makefile are
provided in the samples section of GitHub.</p>
</div>
<div class="section" id="design-example-using-library-on-sdaccel">
<span id="ariaid-title11"></span><h3>Design example Using Library on SDAccel<a class="headerlink" href="#design-example-using-library-on-sdaccel" title="Permalink to this headline">¶</a></h3>
<p>Following is a multi-kernel example, where different kernel runs
sequentially in a pipeline to form an application. This example performs
Canny edge detection, where two kernels are involved, Canny and edge
tracing. Canny function will take gray-scale image as input and provided
the edge information in 3 states (weak edge (1), strong edge (3), and
background (0)), which is being fed into edge tracing, which filters out
the weak edges. The prior works in a streaming based implementation and
the later in a memory mapped manner.</p>
<p><strong>Host code</strong></p>
<p>The following is the Host code for the canny edge detection example. The
host code sets up the OpenCL platform with the FPGA of processing
required data. In the case of xfOpenCV example, the data is an image.
Reading and writing of images are enabled using called to functions from
xfOpenCV.</p>
<p><strong>Top level kernel</strong></p>
<p>Below is the top-level/wrapper function with all necessary glue logic.</p>
</div>
</div>
<div class="section" id="evaluating-the-functionality">
<span id="ariaid-title12"></span><h2>Evaluating the Functionality<a class="headerlink" href="#evaluating-the-functionality" title="Permalink to this headline">¶</a></h2>
<p>You can build the kernels and test the functionality through software
emulation, hardware emulation, and running directly on a supported
hardware with the FPGA. For PCIe based platforms, use the following
commands to setup the environment:</p>
<div class="section" id="software-emulation">
<span id="ariaid-title13"></span><h3>Software Emulation<a class="headerlink" href="#software-emulation" title="Permalink to this headline">¶</a></h3>
<p>Software emulation is equivalent to running a C-simulation of the
kernel. The time for compilation is minimal, and is therefore
recommended to be the first step in testing the kernel. Following are
the steps to build and run for the software emulation:</p>
</div>
<div class="section" id="hardware-emulation">
<span id="ariaid-title14"></span><h3>Hardware Emulation<a class="headerlink" href="#hardware-emulation" title="Permalink to this headline">¶</a></h3>
<p>Hardware emulation runs the test on the generated RTL after synthesis of
the C/C++ code. The simulation, since being done on RTL requires longer
to complete when compared to software emulation. Following are the steps
to build and run for the hardware emulation:</p>
</div>
<div class="section" id="testing-on-the-hardware">
<span id="ariaid-title15"></span><h3>Testing on the Hardware<a class="headerlink" href="#testing-on-the-hardware" title="Permalink to this headline">¶</a></h3>
<p>To test on the hardware, the kernel must be compiled into a bitstream
(building for hardware).</p>
<p>This would consume some time since the C/C++ code must be converted to
RTL, run through synthesis and implementation process before a bitstream
is created. As a prerequisite the drivers has to be installed for
corresponding DSA, for which the example was built for. Following are
the steps to run the kernel on a hardware:</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Xilinx

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>