

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Internal Design of American Option Pricing Engine &mdash; XF FinTech Library 1.0 pre-alpha documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/xilinx-favicon.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Internal Design of MCMultiAssetEuropeanHestonEngine" href="MCMultiAssetEuropeanHestonEngine.html" />
    <link rel="prev" title="Internal Design of Cliquet Option Pricing Engine" href="MCCliquetEngine.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> XF FinTech Library
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Library Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html#license">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html#trademark-notice">Trademark Notice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rel.html">Release Note</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../models_and_methods.html">Pricing models and numerical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guide_L1/L1.html">L1 Module User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../L2.html">L2 Pricing Engine Kernel User Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../overview.html">Pricing Engine Overview</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../kernel_design.html">Pricing Engine Kernel Design</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="MCEuropeanEngine.html">Internal Design of MCEuropeanEngine</a></li>
<li class="toctree-l3"><a class="reference internal" href="MCEuropeanHestonEngine.html">Internal Design of MCEuropeanHestonEngine</a></li>
<li class="toctree-l3"><a class="reference internal" href="MCAsianEngines.html">Internal Design of Asian Option Pricing Engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="MCDigitalEngine.html">Internal Design of Digital Option Pricing Engines</a></li>
<li class="toctree-l3"><a class="reference internal" href="MCBarrierEngine.html">Internal Design of Barrier Option Pricing Engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="MCCliquetEngine.html">Internal Design of Cliquet Option Pricing Engine</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Internal Design of American Option Pricing Engine</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#theory">Theory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="MCMultiAssetEuropeanHestonEngine.html">Internal Design of MCMultiAssetEuropeanHestonEngine</a></li>
<li class="toctree-l3"><a class="reference internal" href="MCEuropeanHestonGreeksEngine.html">Internal Design of MCEuropeanHestonGreeksEngine</a></li>
<li class="toctree-l3"><a class="reference internal" href="CFBlackScholesMerton.html">Internal Design of Closed Form Black-Scholes-Merton</a></li>
<li class="toctree-l3"><a class="reference internal" href="CFHeston.html">Internal Design of Closed Form Heston</a></li>
<li class="toctree-l3"><a class="reference internal" href="M76.html">Internal Design of Closed Form Merton 76</a></li>
<li class="toctree-l3"><a class="reference internal" href="BTCRR.html">Internal Design of Cox-Ross-Rubinstein Binomial Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="FDHullWhiteEngine.html">Internal Design of Finite-difference Hull-White Bermudan Swaption Pricing Engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="TreeEngine.html">Internal Design of Tree Bermudan Swaption Engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="CPICapFloorEngine.html">Internal Design of CPI CapFloor Engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="InflationCapFloorEngine.html">Internal Design of Inflation CapFloor Engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="ZCDiscountingBondEngine.html">Internal Design of Zero Coupon Bond Engine</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_api.html">Pricing Engine Kernel APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_benchmark.html">Pricing Engines Demo</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../guide_L3/L3.html">L3 Overlay User Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Benchmark Result</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../benchmark/benchmark.html">Quality and Performance</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">XF FinTech Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../L2.html">L2 Pricing Engine Kernel User Guide</a> &raquo;</li>
        
          <li><a href="../kernel_design.html">Pricing Engine Kernel Design</a> &raquo;</li>
        
      <li>Internal Design of American Option Pricing Engine</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/guide_L2/engines/MCAmericanEngine.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="internal-design-of-american-option-pricing-engine">
<h1>Internal Design of American Option Pricing Engine<a class="headerlink" href="#internal-design-of-american-option-pricing-engine" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>American Option is an option that can be exercised at any time up until its maturity date. This early exercise feature of American Option gives the investors more freedom to exercise, compared to the European options.</p>
</div>
<div class="section" id="theory">
<h2>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h2>
<p>Because the American option can be exercised anytime prior to the stock’s expire date, exercise price at each time step is required to be calculated in the process of valuing the optimal exercise. More precisely, the pricing process is as follows:</p>
<ol class="arabic simple">
<li>Generate independent stock paths</li>
<li>Start at maturity <span class="math notranslate nohighlight">\(T\)</span> and calculate the exercise price.</li>
<li>Calculate the exercise price for previous time steps <span class="math notranslate nohighlight">\(T-1\)</span>, compare it with the last exercise price, select the larger one.</li>
<li>Keep rolling back to previous time steps until <span class="math notranslate nohighlight">\(t\)</span> is <span class="math notranslate nohighlight">\(0\)</span> and obtain the max exercise price <span class="math notranslate nohighlight">\(V_t\)</span> as the optimal exercise price.</li>
</ol>
<p>In the above process, for each time step <span class="math notranslate nohighlight">\(t\)</span>, conditional expectation <span class="math notranslate nohighlight">\(E_t[Y_t|S_t]\)</span> of the payoff is computed according to Least-Squares Monte Carlo (LSMC) approach, proposed by Longstaff and Schwartz. Mathematically, these conditional expectations can be expressed as:</p>
<div class="math notranslate nohighlight">
\[E_t[Y_t|S_t] = \sum_{i=0}^{n}a_iB_i(S_t)\]</div>
<p>where <span class="math notranslate nohighlight">\(t\)</span> is the time prior to maturity, <span class="math notranslate nohighlight">\(B_i(S_t)\)</span> is the basis function of the values of actual stock prices <span class="math notranslate nohighlight">\(S_t\)</span> at time <span class="math notranslate nohighlight">\(t\)</span>. The constant coefficients of basis functions are written as <span class="math notranslate nohighlight">\(a_i\)</span> , and acts as weights to the basis functions. The discounted subsequent realized cash flows from continuation called <span class="math notranslate nohighlight">\(Y_t\)</span>.</p>
<p>Here we employed polynomial function with weights as the basis functions, so the conditional expectations can be re-written as:</p>
<div class="math notranslate nohighlight">
\[E_t[Y_t|S_t] = a + bS_t + cS_t^2\]</div>
<p>where 3 functions: 1, <span class="math notranslate nohighlight">\(S_t\)</span> and <span class="math notranslate nohighlight">\(S_t^2\)</span> are employed. The constant coefficients <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(c\)</span> are the weights.</p>
<p>By adding immediate exercise value <span class="math notranslate nohighlight">\(E_t(S_t)\)</span> to above Equation, and exchanging the side of elements, the equation is changed to</p>
<div class="math notranslate nohighlight" id="equation-expect-calc">
<span class="eqno">(2)<a class="headerlink" href="#equation-expect-calc" title="Permalink to this equation">¶</a></span>\[a + bS_t + cS_t^2 + dE_t(S_t) = E_t[Y_t|S_t]\]</div>
<p><span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(c\)</span>, <span class="math notranslate nohighlight">\(d\)</span> are constant coefficients. These coefficients need to be known while calculating the optimal exercise price in mcSimulation model. More details of American-style optimal algorithm used in our library refer to <strong>“da Silva, J. N., &amp; Fernández, L. A Monte Carlo Approach to Price American-Bermudan-Style Derivatives.”</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Theoretically, the basis functions <span class="math notranslate nohighlight">\(B_i(S_t)\)</span> can be any complex functions and the number of basis function may be any number. The American Option implemented in our library employs three polynomial functions, namely, 1, <span class="math notranslate nohighlight">\(S_t\)</span> and <span class="math notranslate nohighlight">\(S_t^2\)</span>, which proved by Longstaff and Schwartz that works well, and is a typical setup in real implementations.</p>
</div>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>In the Theory Section, the pricing process is described. However, this process can only be executed in the condition of Equation <a class="reference internal" href="#equation-expect-calc">(2)</a> is given. This means that the coefficients in Equation <a class="reference internal" href="#equation-expect-calc">(2)</a> must be calculated first. This calculation process is called <strong>Calibration</strong> and executes prior to the <strong>Pricing</strong> process. Therefore, in the implementation, the American Monte Carlo Engine contains two processes: <strong>Calibration</strong> and <strong>Pricing</strong>, as illustrated in <a class="reference internal" href="#my-figure-overall"><span class="std std-numref">Figure 10</span></a>.</p>
<div class="figure align-center" id="id1">
<span id="my-figure-overall"></span><a class="reference internal image-reference" href="../../_images/overall_arch.png"><img alt="The McAmericanEngine structure" src="../../_images/overall_arch.png" style="width: 50%;" /></a>
<p class="caption"><span class="caption-number">Figure 10 </span><span class="caption-text"><span class="xref std std-ref">the overview of two processes in American Engine Pricing Option</span></span></p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>Why two processes are required in MCAmericanEngine and only one process, pricing, is enough for European Option Monte Carlo engine?</p>
<div class="last line-block">
<div class="line">For European Option, the exercise price of the stork at the last time step <span class="math notranslate nohighlight">\(T\)</span> needs to be and only need to be calculated. However, for American Option, the exercise price of the stock at all time steps <span class="math notranslate nohighlight">\(t, 0 \leq t \leq T\)</span> are required to be computed. Therefore, the mathematical model of American Option Monte Carlo employs several basis functions, refer to Equation <a class="reference internal" href="#equation-expect-calc">(2)</a>.</div>
<div class="line">In the aspect of basis functions, the European Option employed only one basis function: <span class="math notranslate nohighlight">\(S_T\)</span>, where <span class="math notranslate nohighlight">\(T\)</span> is the maturity date. By introducing multiple basis functions, the coefficients are also introduced. Thus, the calibration process is deployed to compute these coefficients.</div>
</div>
</div>
<div class="section" id="calibration-process">
<h3>Calibration Process<a class="headerlink" href="#calibration-process" title="Permalink to this headline">¶</a></h3>
<p>Calibration process aims to calculate the coefficients that will be used in the pricing process.</p>
<p>The detailed calculation process is as follows:</p>
<ol class="arabic simple">
<li>Generate uniform random numbers with Mersenne Twister UNiform MT19937 Random Number Generator (RNG) followed by Inverse Cumulative Normal (ICN) uniform random numbers. Thereafter, generate independent stock paths with the uniform random numbers and Black-Sholes path generator. The default paths (samples) number used in the calibration process is 4096. Thus, 4096 random numbers are generated for each time step <span class="math notranslate nohighlight">\(t\)</span>.</li>
<li>Refer to Equation <a class="reference internal" href="#equation-expect-calc">(2)</a>, <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(c\)</span>, <span class="math notranslate nohighlight">\(d\)</span> are the unknown coefficients that should be calculated. We denote these coefficients as <span class="math notranslate nohighlight">\(x\)</span>, so</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}x = \begin{bmatrix}
      a \\
      b \\
      c \\
      d
    \end{bmatrix}\end{split}\]</div>
<p>The expressions derived from path data <span class="math notranslate nohighlight">\(S_t\)</span>, <span class="math notranslate nohighlight">\(S_t^2\)</span> and <span class="math notranslate nohighlight">\(E_t\)</span> can be obtained for each time step <span class="math notranslate nohighlight">\(t\)</span>. Here we denote them as <span class="math notranslate nohighlight">\(A\)</span>.</p>
<div class="math notranslate nohighlight">
\[A = \begin{bmatrix}
       1 \ S_t \  S_t^2 \  E_t(S_t)
    \end{bmatrix}\]</div>
<p>Equation <a class="reference internal" href="#equation-expect-calc">(2)</a> can be re-written as:</p>
<div class="math notranslate nohighlight" id="equation-y-ax">
<span class="eqno">(3)<a class="headerlink" href="#equation-y-ax" title="Permalink to this equation">¶</a></span>\[y = A x\]</div>
<p>where <span class="math notranslate nohighlight">\(y\)</span> is the conditional expectation <span class="math notranslate nohighlight">\(E_t(Y_t|S_t)\)</span> in Equation <a class="reference internal" href="#equation-expect-calc">(2)</a>. To simplify the expression in deduction, it is denoted as <span class="math notranslate nohighlight">\(y\)</span> in this section. By backward process, this conditional expectation <span class="math notranslate nohighlight">\(y\)</span> for each time step can be obtained. Which is to say, <span class="math notranslate nohighlight">\(y\)</span> is actually the optimal exercise price in the period of <span class="math notranslate nohighlight">\(t\)</span> to <span class="math notranslate nohighlight">\(T\)</span>.
Therefore, the problem of computing coefficients is changes to find the solution for Equation <a class="reference internal" href="#equation-y-ax">(3)</a>.</p>
<p>In practical, in this step, we calculate the value of 4 elements in vector <span class="math notranslate nohighlight">\(A_t\)</span> for each time step <span class="math notranslate nohighlight">\(t\)</span>. Which is to say, 4 outputs of this stage are <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(S_t\)</span>, <span class="math notranslate nohighlight">\(S_t^2\)</span> and <span class="math notranslate nohighlight">\(E_t\)</span>. The default size of :<span class="math notranslate nohighlight">\(A_t\)</span> for each time step is 4096 * 4.</p>
<p>To simplify the process of solving Equation <a class="reference internal" href="#equation-y-ax">(3)</a>, matrix data <span class="math notranslate nohighlight">\(A\)</span> is multiplied with its transform <span class="math notranslate nohighlight">\(A^T\)</span>. A new 4*4 matrix <span class="math notranslate nohighlight">\(B\)</span> can be derived:</p>
<div class="math notranslate nohighlight">
\[A^T A = B.\]</div>
<p>Corresponding to the two steps described above, the hardware architecture is shown in <a class="reference internal" href="#my-figure-presamples"><span class="std std-numref">Figure 11</span></a>.</p>
<div class="figure align-center" id="id2">
<span id="my-figure-presamples"></span><a class="reference internal image-reference" href="../../_images/presamples.png"><img alt="The McAmericanEngine structure" src="../../_images/presamples.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Figure 11 </span><span class="caption-text"><span class="xref std std-ref">the structure of American engine calibration process - phase 1: Presamples</span></span></p>
</div>
<p>We denote the process from RNG to generate matrix data <span class="math notranslate nohighlight">\(B\)</span> and exercise price for each timestep <span class="math notranslate nohighlight">\(t\)</span> as a Monte-Carlo-Model (MCM) in American Option Calibration Process. Each MCM process 1024 data. With a template parameter UN_PATH, more pieces of MCM can be instanced when hardware resources available.</p>
<p>To connect multiple MCM data, two merger blocks are created: one for merge price data, one for merge matrix <span class="math notranslate nohighlight">\(B\)</span>. Meanwhile, to guarantee all calibration path data can be executed in a loop when not enough MCM available, a soft-layer Merger that accumulates all elements of <span class="math notranslate nohighlight">\(B\)</span> data is employed. Since these intermediate data need to be accumulated multiple times, a BRAM is used to save and load them.</p>
<ol class="arabic simple" start="3">
<li>Once we get the matrix <span class="math notranslate nohighlight">\(B\)</span>, the singular matrix <span class="math notranslate nohighlight">\(\Sigma\)</span> of <span class="math notranslate nohighlight">\(B\)</span> could be obtained by SVD (Singular Value Decomposition).</li>
</ol>
<div class="math notranslate nohighlight">
\[B = U \Sigma V.\]</div>
<ol class="arabic simple" start="4">
<li>Thereafter, use Least-Squares to calculated the coefficients by modifying Equation <a class="reference internal" href="#equation-y-ax">(3)</a> to:</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}y &amp;= A x \\
A^T y &amp;= A^TA x \\
A^T y &amp;= Bx\end{split}\]</div>
<p>Until now, matrix <span class="math notranslate nohighlight">\(B\)</span> and vector <span class="math notranslate nohighlight">\(y\)</span> are known, coefficients <span class="math notranslate nohighlight">\(x\)</span> could be calculated.</p>
<div class="figure align-center" id="id3">
<span id="my-figure-calib"></span><a class="reference internal image-reference" href="../../_images/calibrate.png"><img alt="The McAmericanEngine structure" src="../../_images/calibrate.png" style="width: 60%;" /></a>
<p class="caption"><span class="caption-number">Figure 12 </span><span class="caption-text"><span class="xref std std-ref">the structure of American engine calibration process - phase 2: Calibrate</span></span></p>
</div>
<p>The implementation of step 3 and steps 4 is shown in <a class="reference internal" href="#my-figure-calib"><span class="std std-numref">Figure 12</span></a>. Because step 2 generates matrix <span class="math notranslate nohighlight">\(B\)</span> and price data <span class="math notranslate nohighlight">\(y\)</span> from timesteps <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(T\)</span>. Step 3 processes these data in the backward direction, from timesteps <span class="math notranslate nohighlight">\(T\)</span> to <span class="math notranslate nohighlight">\(0\)</span>. Considering the amount of data, 4096*timesteps*8*sizeof(DT) and 9*timesteps*8*sizeof(DT), it is impossible to store all the data on FPGA. In the implementation, DDR/HBM memory is used to save these data. Correspondingly, DDR data read/write modules are added to the design.</p>
<p>Besides, notice that since SVD is purely computing dependent, which is pretty slow in the design. Therefore, a template parameter UN_STEP is added to speed up the SVD calculation process.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is worth mentioning that 4096 is only the default calibrate sample/path size. This number may change by customers’ demands. However, the size number must equal to N*1024.</p>
</div>
</div>
<div class="section" id="pricing-process">
<h3>Pricing Process<a class="headerlink" href="#pricing-process" title="Permalink to this headline">¶</a></h3>
<div class="section" id="mcamericanenginepricing">
<h4>MCAmericanEnginePricing<a class="headerlink" href="#mcamericanenginepricing" title="Permalink to this headline">¶</a></h4>
<p>The theory of the pricing process is actually already introduced in the Theory Section. Similar to the European option engine, etc other option engines, mcSimulation framework is employed. Compared to the European option engine, the difference is that it needs to calculate the optimal exercise at all time steps. The detailed implementation process of American engine is drawn as Figure <a class="reference internal" href="#my-figure-pricing"><span class="std std-numref">Figure 13</span></a> shows.</p>
<div class="figure align-center" id="id4">
<span id="my-figure-pricing"></span><a class="reference internal image-reference" href="../../_images/pricing.png"><img alt="The McAmericanEngine structure pricing" src="../../_images/pricing.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Figure 13 </span><span class="caption-text"><span class="xref std std-ref">the structure of American engine pricing process</span></span></p>
</div>
<ol class="arabic simple">
<li>Generate uniform random numbers with Mersenne Twister UNiform MT19937 Random Number Generator (RNG) followed by Inverse Cumulative Normal (ICN) uniform random numbers. Thereafter, generate independent stock paths with the uniform random numbers and Black-Sholes path generator.</li>
<li>Refer to Equation <a class="reference internal" href="#equation-expect-calc">(2)</a>, calculate the exercise price at time step <span class="math notranslate nohighlight">\(T\)</span> by utilizing the calculated coefficients <span class="math notranslate nohighlight">\(x\)</span>.</li>
<li>Calculate the exercise price for previous time steps <span class="math notranslate nohighlight">\(t\)</span>, and take the max exercise price by comparing the immediate exercise price with the held price value (maximum value for time steps <span class="math notranslate nohighlight">\(t+1\)</span>).</li>
<li>Continue this process, until time step <span class="math notranslate nohighlight">\(t\)</span> equals 0, optimal exercise price and the standard deviation is obtained.</li>
<li>Check if the standard deviation is smaller than the required tolerance defined by customers. If not, repeat step 1-4, until the final optimal exercise price is obtained.</li>
</ol>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Notice that the pricing module also supports another approach of ending pricing process, which utilizes the input parameter <em>requiredSamples</em>. When the <em>requiredSamples</em> are processed, we assume the output mean result is the final optimal exercise price. This mode is also supported in the American Option Pricing Engine. And the figure above only illustrates the ending approach with the required tolerance.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the figure, BRAM is used to load coefficients data that calculated from the calibration process. Here may use BRAM or DDR, it depends on the amount of data that need to be stored beforehand. The reason that coefficients data cannot be streamed is that the multi-Monte-Carlo process in pricing always needs to execute multiple times. Each time execution, these need to be loaded. Thus, it is impossible to use <em>hls::stream</em>.</p>
</div>
</div>
</div>
<div class="section" id="mcamericanengine-apis">
<h3>MCAmericanEngine APIs<a class="headerlink" href="#mcamericanengine-apis" title="Permalink to this headline">¶</a></h3>
<p>In our library, the MCAmerican Option Pricing with Monte Carlo simulation is provided as an API MCAmericanEngine(). However, due to external memory usage on DDR/HBM and avoiding the designed hardware cross-SLR placed and routed. The American engine option supports two modes:</p>
<ul class="simple">
<li><strong>single API version</strong>: use one API to run the whole American option</li>
<li><strong>three APIs version</strong>: three APIs/kernels are provided, connecting them on the host side to compose the overall design.</li>
</ul>
<p>The boundary between them is external memory access. For the calibration process, two APIs are provided. Calibration step 1 and 2 are wrapped as one kernel, namely, <strong>MCAmericanEnginePreSamples</strong>. Step 3 and step 4 compose another kernel <strong>MCAmericanEngineCalibrate</strong>. And pricing process as another kernel <strong>MCAmericanEnginePricing</strong> in this library. Because the pricing process is separated as a kernel, the data exchange between the calibration and pricing process may not through the BRAM any more. Thus, in the implementation, DDR/HBM is used as the coefficients data storage memory.</p>
<p>With the three kernels, the kernel level pipeline by shortening the overall execution time could be achieved. However, employing kernel level pipeline requires a complex schedule from the host code side. An illustration of connection 3 kernels as a complete system is given in this part, which can be seen in <a class="reference internal" href="#my-figure-sdx"><span class="std std-numref">Figure 14</span></a>. Price data and <span class="math notranslate nohighlight">\(B\)</span> matrix data are the outputs from kernel MCAmericanEnginePreSamples. For each timestep, path number (default 4096) price data B and x matrix data (a number of 9) need to be saved to DDR or HBM memory.</p>
<div class="figure align-center" id="id5">
<span id="my-figure-sdx"></span><a class="reference internal image-reference" href="../../_images/sdx_structure.png"><img alt="McAmericanEngine Vitis project architecture on FPGA" src="../../_images/sdx_structure.png" style="width: 60%;" /></a>
<p class="caption"><span class="caption-number">Figure 14 </span><span class="caption-text"><span class="xref std std-ref">the architecture of 3-kernel version MCAmericanEngine on FPGA</span></span></p>
</div>
<p>Kernel 1 MCAmericanEngineCalibrate reads price data <span class="math notranslate nohighlight">\(y\)</span> and matrix data <span class="math notranslate nohighlight">\(B\)</span> from external memory and outputs coefficients to DDR/HBM. The last kernel MCAmericanEnginePricing reads coefficients data from DDR/HBM and saves the final output optimal exercise price to DDR/HBM.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>Why the number of matrix B is 9 in DDR/HBM?</p>
<p>The matrix <span class="math notranslate nohighlight">\(A\)</span> is 4096 * 4 for each timestep when the path number is 4096 (default). The size of its transform matrix <span class="math notranslate nohighlight">\(A^T\)</span> is 4 * 4096. So, the size of matrix <span class="math notranslate nohighlight">\(B\)</span> is 4 * 4. However, some elements in <span class="math notranslate nohighlight">\(B\)</span> are the same, and 9 can represent all 16 data. More precisely, assuming</p>
<div class="math notranslate nohighlight">
\[\begin{split}  A^T = \begin{bmatrix}
        &amp;1\      1\      ...\  1\     ...\  1    \\
        &amp;S_0\    S_1\    ...\  S_t\   ...\  S_T  \\
        &amp;S_0^2\  S_1^2\  ...\  S_t^2\ ...\  S_T^2\\
        &amp;E_0\    E_1\    ...\  E_t\   ...\  E_T
      \end{bmatrix}, \ \  \ \
A = \begin{bmatrix}
        1\  S_0\  S_0^2\  E_0 \\
        1\  S_1\  S_1^2\  E_1 \\
        ...                   \\
        1\  S_t\  S_t^2\  E_t \\
        ...                    \\
        1\  S_T\  S_T^2\  E_T
      \end{bmatrix} \\
  \\
  ==&gt;
  B = A^T \ A = \begin{bmatrix}
                     \sum(1)\     \sum(S_i)\    \sum(S_i^2)\   \sum(E_i) \\
                     \sum(S_i)\   \sum(S_i^2)\  \sum(S_i^3)\   \sum(S_iE_i) \\
                     \sum(S_i^2)\ \sum(S_i^3)\  \sum(S_i^4)\   \sum(S_i^2E_i) \\
                     \sum(E_i)\   \sum(S_iE_i)\ \sum(S_i^2E_i)\ \sum(E_i^2) \\
                    \end{bmatrix}\end{split}\]</div>
<p>It is evident that some elements are the same. After removing duplicated elements, the following 9 elements of <span class="math notranslate nohighlight">\(B\)</span> are stored to DDR/HBM each timestep:</p>
<div class="last math notranslate nohighlight">
\[\begin{split}B_{save} = \begin{bmatrix}
           &amp;\sum(1)\    \\
           &amp;\sum(S_i)\    \\
           &amp;\sum(S_i^2)\ \sum(S_i^3)\  \sum(S_i^4)\   \\
           &amp;\sum(E_i)\   \sum(S_iE_i)\ \sum(S_i^2E_i)\ \sum(E_i^2)
         \end{bmatrix}\end{split}\]</div>
</div>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">The architecture illustrated above is only an example design. In fact, multiple numbers of kernels, each with a different unroll number (UN) may be deployed. The number of kernels that can be instanced in design depends on the resource/size of the FPGA.</p>
</div>
<div class="toctree-wrapper compound">
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="MCMultiAssetEuropeanHestonEngine.html" class="btn btn-neutral float-right" title="Internal Design of MCMultiAssetEuropeanHestonEngine" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="MCCliquetEngine.html" class="btn btn-neutral" title="Internal Design of Cliquet Option Pricing Engine" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Xilinx Inc.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>